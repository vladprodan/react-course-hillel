# Рішення: Використання хука `use()` в React

## Крок 1: Створення імітації API

Спочатку створимо асинхронну функцію `fetchUser`, яка імітує запит до API:

```javascript
// Імітація API запиту
const fetchUser = (id) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      // Імітуємо затримку мережі 2 секунди
      resolve({
        id: id,
        name: "Іван",
        role: id === 1 ? "admin" : "guest", // admin для id=1, guest для інших
        email: "ivan@example.com",
      });
    }, 2000);
  });
};
```

**Пояснення:** Ця функція повертає проміс, який вирішується через 2 секунди. Це імітує реальний API запит з мережевою затримкою.

---

## Крок 2: Створення контексту Settings

Створюємо контекст для налаштувань, який містить інформацію про дозволи редагування:

```javascript
import { createContext } from "react";

// Створюємо контекст для налаштувань
const SettingsContext = createContext(null);
```

**Пояснення:** `SettingsContext` буде використовуватися для передачі інформації про права редагування через дерево компонентів.

---

## Крок 3: Створення компонента UserCard

Тепер створимо основний компонент `UserCard`, який використовує хук `use()`:

```javascript
import { use } from "react";

function UserCard({ userPromise }) {
  // 1. Використовуємо use() для "розпакування" промісу
  const user = use(userPromise);

  // 2. Змінна для зберігання прав редагування
  let canEditSettings = false;

  // 3. Умовне використання use() для контексту
  if (user.role === "admin") {
    const settings = use(SettingsContext);
    canEditSettings = settings.canEdit;
  }

  // 4. Відображення UI
  return (
    <div
      style={{
        border: "2px solid #4CAF50",
        padding: "20px",
        borderRadius: "8px",
        maxWidth: "400px",
        margin: "20px auto",
      }}
    >
      <h2>Картка Користувача</h2>
      <p>
        <strong>Ім'я:</strong> {user.name}
      </p>
      <p>
        <strong>Email:</strong> {user.email}
      </p>
      <p>
        <strong>Роль:</strong> {user.role}
      </p>

      {/* Умовне відображення кнопки редагування */}
      {canEditSettings && (
        <button
          style={{
            backgroundColor: "#4CAF50",
            color: "white",
            padding: "10px 20px",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
            marginTop: "10px",
          }}
        >
          Редагувати Налаштування
        </button>
      )}
    </div>
  );
}
```

**Пояснення ключових моментів:**

- `use(userPromise)` автоматично "розпаковує" проміс і призупиняє рендеринг до його виконання
- Хук `use()` викликається **умовно** всередині `if` блоку - це унікальна можливість `use()`, яку не мають інші хуки
- Немає потреби в `useState` або `useEffect` для управління станом завантаження

---

## Крок 4: Створення кореневого компонента App

Тепер зберемо все разом у головному компоненті:

```javascript
import { Suspense, useState } from "react";

function App() {
  // Створюємо проміси для різних користувачів
  const [userId, setUserId] = useState(1);
  const userPromise = fetchUser(userId);

  return (
    <div style={{ padding: "20px", fontFamily: "Arial, sans-serif" }}>
      <h1>Демонстрація хука use()</h1>

      {/* Кнопки для перемикання між користувачами */}
      <div style={{ marginBottom: "20px" }}>
        <button
          onClick={() => setUserId(1)}
          style={{ marginRight: "10px", padding: "10px" }}
        >
          Завантажити Admin (ID: 1)
        </button>
        <button onClick={() => setUserId(2)} style={{ padding: "10px" }}>
          Завантажити Guest (ID: 2)
        </button>
      </div>

      {/* Provider контексту */}
      <SettingsContext.Provider value={{ canEdit: true }}>
        {/* Suspense обробляє стан завантаження */}
        <Suspense
          fallback={
            <div
              style={{
                textAlign: "center",
                padding: "40px",
                fontSize: "20px",
                color: "#666",
              }}
            >
              <h1>Завантаження даних користувача...</h1>
            </div>
          }
        >
          <UserCard userPromise={userPromise} />
        </Suspense>
      </SettingsContext.Provider>
    </div>
  );
}

export default App;
```

**Пояснення структури:**

- `SettingsContext.Provider` надає значення `{ canEdit: true }` для всіх дочірніх компонентів
- `Suspense` автоматично показує fallback під час завантаження даних
- Кнопки дозволяють тестувати різних користувачів (admin vs guest)

---

## Крок 5: Повний код у одному файлі

Ось повний робочий приклад:

```javascript
import { createContext, use, Suspense, useState } from "react";

// 1. Імітація API
const fetchUser = (id) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        id: id,
        name: "Іван",
        role: id === 1 ? "admin" : "guest",
        email: "ivan@example.com",
      });
    }, 2000);
  });
};

// 2. Створення контексту
const SettingsContext = createContext(null);

// 3. Компонент UserCard
function UserCard({ userPromise }) {
  const user = use(userPromise);

  let canEditSettings = false;

  if (user.role === "admin") {
    const settings = use(SettingsContext);
    canEditSettings = settings.canEdit;
  }

  return (
    <div
      style={{
        border: "2px solid #4CAF50",
        padding: "20px",
        borderRadius: "8px",
        maxWidth: "400px",
        margin: "20px auto",
      }}
    >
      <h2>Картка Користувача</h2>
      <p>
        <strong>Ім'я:</strong> {user.name}
      </p>
      <p>
        <strong>Email:</strong> {user.email}
      </p>
      <p>
        <strong>Роль:</strong> {user.role}
      </p>

      {canEditSettings && (
        <button
          style={{
            backgroundColor: "#4CAF50",
            color: "white",
            padding: "10px 20px",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
            marginTop: "10px",
          }}
        >
          Редагувати Налаштування
        </button>
      )}
    </div>
  );
}

// 4. Головний компонент
function App() {
  const [userId, setUserId] = useState(1);
  const userPromise = fetchUser(userId);

  return (
    <div style={{ padding: "20px", fontFamily: "Arial, sans-serif" }}>
      <h1>Демонстрація хука use()</h1>

      <div style={{ marginBottom: "20px" }}>
        <button
          onClick={() => setUserId(1)}
          style={{ marginRight: "10px", padding: "10px" }}
        >
          Завантажити Admin (ID: 1)
        </button>
        <button onClick={() => setUserId(2)} style={{ padding: "10px" }}>
          Завантажити Guest (ID: 2)
        </button>
      </div>

      <SettingsContext.Provider value={{ canEdit: true }}>
        <Suspense
          fallback={
            <div style={{ textAlign: "center", padding: "40px" }}>
              <h1>Завантаження даних користувача...</h1>
            </div>
          }
        >
          <UserCard userPromise={userPromise} />
        </Suspense>
      </SettingsContext.Provider>
    </div>
  );
}

export default App;
```

---

## Тестування

### Тест 1: Admin користувач

1. Натисніть кнопку "Завантажити Admin (ID: 1)"
2. Протягом 2 секунд відобразиться: "Завантаження даних користувача..."
3. Після завантаження з'явиться картка з кнопкою "Редагувати Налаштування"

### Тест 2: Guest користувач

1. Натисніть кнопку "Завантажити Guest (ID: 2)"
2. Протягом 2 секунд відобразиться індикатор завантаження
3. Після завантаження з'явиться картка **без** кнопки редагування

---

## Переваги використання `use()`

✅ **Немає `useEffect`** - не потрібно управляти життєвим циклом  
✅ **Немає `useState` для завантаження** - Suspense обробляє це автоматично  
✅ **Умовні виклики** - `use()` можна викликати всередині умов  
✅ **Простіший код** - менше шаблонного коду  
✅ **Автоматичне керування помилками** - через Error Boundaries
